:PROPERTIES:
:ID:       20260103T222522
:END:
#+title: 计算机体系结构

* 入门

[[https://cpu.land/][Putting the “You” in CPU]]

* Bootstrapping

https://github.com/oriansj/stage0

* 编译原理和框架

** Non-JIT

- [[https://ecs.openbrace.org/manual/manualse4.html#x9-80002.1][ECS]]
- [[https://news.ycombinator.com/item?id=40346320][QBE]]
  - [[https://news.ycombinator.com/item?id=25273907][QBE vs LLVM]]

** JIT

- [[https://github.com/vnmakarov/mir][MIR]]
  - https://developers.redhat.com/blog/2020/01/20/mir-a-lightweight-jit-compiler-project
- [[https://github.com/bytecodealliance/wasmtime/tree/main/cranelift][Cranelift]]

** Virtual Machines

*** Pointer tagging

https://coredumped.dev/2024/09/09/what-is-the-best-pointer-tagging-method/

结论：这些方案的性能没有太本质的差异，相比较下 cache 命中率要重要得多。文章最后提到还有很多 tagging 的方案和用法，并给了参考文献。

* OS

Lisps! https://gitlab.com/weinholt/loko https://github.com/froggey/Mezzano

* Coroutines

用 Duff's Device + static variable 实现 [[https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html][Coroutine]]，用一个隐藏的状态量做 switch，
用行号作为 case 行对应的状态值，每次重入时跳转到上次执行后面的一个 case。需要手动把重入时需要
恢复的变量标记为 static。由此看出 Duff's Device 是把 switch case 当成动态的 goto 使用。

相关： [[https://eli.thegreenplace.net/2012/07/12/computed-goto-for-efficient-dispatch-tables][computed goto]] 可以提升这里的性能：增加 branch prediction point，绕开
switch case 的 boundary检查。
