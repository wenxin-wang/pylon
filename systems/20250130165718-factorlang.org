:PROPERTIES:
:ID:       20250130T165718
:END:
#+title: FactorLang

https://factorcode.org/

这是我在 2024 年找到的除了 [[id:20250130T165821][APL]] 之外最有意思的语言，简洁烧脑。它继承了 [[id:20250130T165901][Forth]] 的
“连接式”（concatenative）函数调用方式，同样也是一门基于栈的编程语言。但是通过引
入 quotation 这一概念，它又非常的函数式。

它让我感到激动，因为它的代码和概念非常简洁。用这样的“积木”往往能搭出超乎想象的造
物。

它也让我感到困惑。我不能用名字来引用一个环境内的“对象”，必须用栈上的位置来选
取对象。这样确实解耦了“环境”和“对象”，带来了很多好处，例如 closure/quotation 的
内容非常易于打印；但是却引入了对“位置”的强依赖，无论是编写还是阅读程序都需要额外
思考栈的位置。

这样的结果是，这门语言在动态的开发环境里似乎非常易于检视，但是在纸面上打印出来，
却很难给没有同样背景知识的人传达想法。例如，如果不知道函数们的输入输出数量（栈作
用，Stack Effact），连在脑子里生成语法树都做不到，更不要提理解代码的实际作用。

我还在继续体验它的动态交互环境。

* 关于 Factor 的词法分析

它的 parsing stack 和 data stack 构成了两个栈，也就是说假如需要，它可以临时从一
个栈语言（后入先出）变成一个队列语言（先入先出）。例如 {} 的数组语法，先入的元素在
数组的前面，由上面两个栈的处理，不需要专门在出数据栈时反序。
